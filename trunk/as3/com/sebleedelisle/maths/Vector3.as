package com.sebleedelisle.maths {			public class Vector3 {				public var x:Number;		public var y:Number;		public var z:Number;		public static var TO_DEGREES : Number = 180/Math.PI;				public static var TO_RADIANS : Number = Math.PI/180;				public static var temp : Vector3 = new Vector3(); 				public function Vector3 (x : Number = 0, y : Number = 0, z : Number = 0)		{			this.x = x;			this.y = y;			this.z = z;		}				public function toString(decPlaces : int = 3):String		{			var scalar : Number = Math.pow(10,decPlaces); 			return "[" + Math.round (x * scalar) / scalar + ", " + Math.round (y * scalar) / scalar + ", " + Math.round (z * scalar) / scalar + "]";		}				public function clone():Vector3		{			return new Vector3(x, y, z);		}				public function copyTo(v:Vector3):void		{			v.x = x;			v.y = y;			v.z = z;		}				public function copyFrom(v:Vector3):void		{			x = v.x;			y = v.y;			z = v.z;		}					public function magnitude():Number 		{			return Math.sqrt((x*x)+(y*y)+(z*z));		}				public function magnitudeSquared() : Number		{			return (x*x)+(y*y)+(z*z);		}				public function normalise():void 		{			var m:Number = magnitude();						//if (m<=tol) m = 1;						x/=m;			y/=m;			z/=m;			//if (Math.abs(returnvector.x)<tol) w.x = 0.0;			//if (Math.abs(returnvector.y)<tol) w.y = 0.0;			//if (Math.abs(returnvector.z)<tol) w.y = 0.0;						}				public function reverse():void 		{			x = -x;			y = -y;			z = -z;		}				public function plusEq(v:Vector3): void 		{			x+=v.x;			y+=v.y;			z+=v.z;		}				public function plusNew(v:Vector3):Vector3		{			return new Vector3(x+v.x, y+v.y,z+v.z); 		}				public function minusEq(v:Vector3): void 		{			x-=v.x;			y-=v.y;			z-=v.z;		}		public function minusNew(v:Vector3):Vector3		{			 //with(this){ 			 	return new Vector3(x-v.x, y-v.y,z-v.z); 			// };		}					public function multiplyEq(value:Number): void		{			x*=value;			y*=value;			z*=value;	}				public function multiplyNew(v:Number) : Vector3		{			var returnvec:Vector3 = clone();			returnvec.multiplyEq(v);			return returnvec;		}				public function dividedEq(value:Number) : void		{			x/=Number(value);			y/=Number(value);			z/=Number(value);		}				public function dividedNew(v:Number) : Vector3		{			var returnvec:Vector3 = clone();			returnvec.dividedEq(v);			return returnvec;		}				public function cross(v:Vector3) : void		{			temp.copyFrom(this); 			x = (temp.y*v.z)-(temp.z*v.y);			y = (-temp.x*v.z)+(temp.z*v.x);			z = (temp.x*v.y)-(temp.y*v.x);		}				public function crossNew(v:Vector3):Vector3		{			var returnvec:Vector3 = clone();			returnvec.cross(v);			return returnvec;		}				public function dot(v:Vector3):Number		{			return (x * v.x) + (y * v.y) + (z * v.z);		}				public function isEqualTo(v:Vector3) : Boolean		{			return (x==v.x)&&(y==v.y)&&(z==v.z);		}				public function isCloseTo(v:Vector3, distance:Number) : Boolean		{			if(this.isEqualTo(v)) return true;						temp.copyFrom(this); 			temp.minusEq(v);						return (temp.magnitudeSquared()<(distance*distance));		}					public function isMagLessThan(distance:Number) : Boolean		{			return (magnitudeSquared()<(distance*distance));		}				public function isMagGreaterThan(distance:Number) : Boolean		{			return (magnitudeSquared() > (distance*distance));		}				public function rotateYAroundPoint(originPoint:Vector3, angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos((useDegrees ? angle * TO_DEGREES : angle));			var sinRY:Number = Math.sin((useDegrees ? angle * TO_DEGREES : angle));				temp.copyFrom(this); 			temp.minusEq(originPoint);				x= (temp.x*cosRY)+(temp.z*sinRY);			y = temp.y;			z= (temp.x*-sinRY)+(temp.z*cosRY);						plusEq(originPoint);		}				public function rotateZAroundPoint(originPoint:Vector3, angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos((useDegrees ? angle * TO_DEGREES : angle));			var sinRY:Number = Math.sin((useDegrees ? angle * TO_DEGREES : angle));				temp.copyFrom(this); 			temp.minusEq(originPoint);				x= (temp.x*cosRY)-(temp.y*sinRY);			y= (temp.x*sinRY)+(temp.y*cosRY);			z = temp.z;				plusEq(originPoint);			}					public function rotateXAroundPoint(originPoint:Vector3, angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos((useDegrees ? angle * TO_DEGREES : angle));			var sinRY:Number = Math.sin((useDegrees ? angle * TO_DEGREES : angle));				temp.copyFrom(this); 			temp.minusEq(originPoint);						x= temp.x;			y = (temp.y*cosRY)+(temp.z*sinRY);			z= (temp.y*-sinRY)+(temp.z*cosRY);						plusEq(originPoint);		}						public function rotateX(angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos(useDegrees ? angle * TO_DEGREES : angle);			var sinRY:Number = Math.sin(useDegrees ? angle * TO_DEGREES : angle);				temp.copyFrom(this); 				y = (temp.y*cosRY)-(temp.z*sinRY);			z= (temp.y*sinRY)+(temp.z*cosRY);					}				public function rotateY(angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos(useDegrees ? angle * TO_DEGREES : angle);			var sinRY:Number = Math.sin(useDegrees ? angle * TO_DEGREES : angle);				temp.copyFrom(this); 				x= (temp.x*cosRY)+(temp.z*sinRY);			z= (temp.x*-sinRY)+(temp.z*cosRY);		}					public function rotateZ(angle:Number, useDegrees : Boolean = true) :void		{			var cosRY:Number = Math.cos(useDegrees ? angle * TO_DEGREES : angle);			var sinRY:Number = Math.sin(useDegrees ? angle * TO_DEGREES : angle);				temp.copyFrom(this); 					x= (temp.x*cosRY)-(temp.y*sinRY);			y= (temp.x*sinRY)+(temp.y*cosRY);		}							public function reset(x:Number, y:Number, z:Number):void		{			this.x = x;			this.y = y;			this.z = z;		}				public function getDistanceFromSquared(v : Vector3) : Number		{			var dx : Number = v.x - x;			var dy : Number = v.y - y; 			var dz : Number = v.z - z; 			 			return((dx*dx)+(dy*dy)+(dz*dz));			}				public function getDistanceFrom(v : Vector3) : Number		{			// TODO would probably be faster to inline 			return Math.sqrt(getDistanceFromSquared(v)); 		}	}}